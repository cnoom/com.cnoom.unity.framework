# 🎮 CnoomFramework 设计文档

## 📌 核心定位

框架管理类（`App` 或 `FrameworkManager`）是整个框架的唯一核心单例，负责：

* 管理 **模块** 的生命周期
* 持有 **事件总线（EventBus）**
* 提供 **调试、契约验证、依赖管理、Mock替换、热替换** 等附加能力

> ⚠️ 框架中所有功能单元都是 **模块**，不存在服务概念。模块间不直接依赖，一切通信通过 **事件 / 请求-响应 / 广播** 完成。

---

## 🏗️ 管理类功能清单

### 1️⃣ 模块生命周期管理

模块支持三阶段生命周期：

| 阶段         | 功能            | 说明                    |
| ---------- | ------------- | --------------------- |
| `Init`     | 注册事件、准备资源     | 异常捕获并记录；支持特性自动注册事件订阅  |
| `Start`    | 启动逻辑，可安全发送事件  | 依赖模块已全部初始化完成          |
| `Shutdown` | 清理资源、自动取消事件订阅 | 异常不会中断全局；可重置模块状态用于热替换 |

#### 模块状态管理

```csharp
public enum ModuleState
{
    Uninitialized,
    Initialized,
    Started,
    Shutdown
}
```

* 框架可通过事件或调试工具追踪模块状态
* 便于热替换和事件流可视化

#### 依赖声明

```csharp
[DependsOn(typeof(DataModule))]
public class CombatModule : IModule { … }
```

* 框架自动排序模块初始化顺序
* 对中小型项目，依赖声明可选，由开发者手动管理

#### 延迟初始化与事件缓存

* 未准备好时事件可缓存，顺序保持
* 可配置最大缓存长度或延迟策略
* 简化方案：只缓存关键事件，其他事件丢弃或延迟一帧

#### 异常处理策略

* 默认“记录 + 继续初始化”，可选“异常停止后续模块 Init”

---

### 2️⃣ 事件总线（EventBus）

#### 特性自动订阅/取消注册

```csharp
[SubscribeEvent(typeof(IHealthChangedEvent))]
private void OnHealthChanged(IHealthChangedEvent evt)
{
    ui.UpdateHealthBar(evt.NewValue);
}
```

* Init 时自动注册事件
* Shutdown 时自动解绑
* 支持优先级、异步处理、继承分发

#### 框架级事件接口

```csharp
// 所有框架事件继承 IFrameworkEvent
public interface IFrameworkEvent { }

// 模块注册事件
public interface IModuleRegisteredEvent : IFrameworkEvent
{
    string ModuleName { get; }
}

// 模块注销事件
public interface IModuleUnregisteredEvent : IFrameworkEvent
{
    string ModuleName { get; }
}
```

#### 框架事件示例

```csharp
// 模块注册
_eventBus.Publish<IModuleRegisteredEvent>(
    new ModuleRegisteredEvent(module.Name)
);

// 模块注销
_eventBus.Publish<IModuleUnregisteredEvent>(
    new ModuleUnregisteredEvent(module.Name)
);

// 特性订阅
[SubscribeEvent]
private void OnModuleRegistered(IModuleRegisteredEvent evt)
{
    logger.Log($"模块注册：{evt.ModuleName}");
}
```

---

### 3️⃣ 调试与事件流可视化

* **事件日志服务**：记录事件类型、发送者、接收者、时间戳
* **事件流可视化（Editor 工具）**：

  * 功能事件与框架事件分层显示
  * 点击事件可查看模块方法、调用顺序、状态

> ⚠️ 高频逻辑建议关闭详细日志

---

### 4️⃣ 性能分层通信

* **低频逻辑** → 事件总线（UI刷新、战斗结果、模块注册/注销）
* **高频逻辑** → 模块间直接调用（战斗 Tick、数值运算）
* **异步事件处理**：

  * 高频事件可异步队列处理
  * 避免阻塞主线程

---

### 5️⃣ Mock / 替换实现

* 模块通过接口注册，可替换 Mock 实现：

```csharp
App.Register<ICombatModule>(new MockCombatModule());
```

* 生命周期绑定，热替换时可临时替换模块实现
* 快速模块模板包含生命周期方法、特性注册示例、Mock 支持

---

### 6️⃣ 安全防护

* **契约验证**：确保事件/请求在契约中定义
* **异常保护**：事件分发捕获异常，避免单模块崩溃影响全局
* **热替换支持**：

  * 模块状态可保留或重置
  * 自动处理事件缓存

---

## 📊 模块通信示例

```csharp
// 功能事件
public interface ICombatEvent { }
public interface IHealthChangedEvent : ICombatEvent
{
    int OldValue { get; }
    int NewValue { get; }
}

// 发布功能事件
_eventBus.Publish<IHealthChangedEvent>(
    new HealthChangedEvent(oldValue, newValue)
);

// 特性订阅
[SubscribeEvent(typeof(IHealthChangedEvent))]
private void OnHealthChanged(IHealthChangedEvent evt)
{
    ui.UpdateHealthBar(evt.NewValue);
}

// 框架级事件订阅
[SubscribeEvent(typeof(IModuleRegisteredEvent))]
private void OnModuleRegistered(IModuleRegisteredEvent evt)
{
    logger.Log($"模块注册：{evt.ModuleName}");
}

// 请求/响应示例
var inventory = _eventBus.Request<GetInventoryRequest, Inventory>();
```

---

## ✅ 总结

最终特性：

* 模块完全解耦，依赖通过事件/请求完成
* 生命周期管理清晰，支持状态追踪与热替换
* 事件系统强大且易用，支持特性自动注册、优先级、异步、继承分发
* 框架级事件接口，跟踪模块注册/注销/状态变化
* 性能分层通信，高频逻辑直接调用，低频逻辑走事件
* 调试与可视化工具完善
* Mock替换和快速模块模板支持测试与原型开发
* 异步事件处理，降低主线程阻塞

> 适合中小型项目快速开发，保持模块解耦、可维护性高、调试友好。
