# 🚀 性能监控系统使用示例

## 快速开始

### 1. 启用性能监控

```csharp
// 在框架初始化后启用性能监控
public class GameManager : MonoBehaviour
{
    void Start()
    {
        // 初始化框架
        var frameworkManager = FrameworkManager.Instance;
        frameworkManager.Initialize();
        
        // 获取并启用性能监控
        var performanceMonitor = PerformanceMonitor.Instance;
        performanceMonitor.SetEnabled(true);
        
        // 初始化性能拦截器
        PerformanceInterceptor.Initialize(performanceMonitor);
        
        Debug.Log("性能监控系统已启用");
    }
}
```

### 2. 使用特性标记监控方法

```csharp
public class PlayerController : BaseModule
{
    [MonitorPerformance("玩家更新")]
    void Update()
    {
        ProcessInput();
        UpdateMovement();
        UpdateAnimation();
    }
    
    [MonitorPerformance("输入处理", true)]
    private void ProcessInput()
    {
        // 输入处理逻辑
        if (Input.GetKey(KeyCode.W))
            transform.Translate(Vector3.forward * Time.deltaTime * 5f);
    }
    
    [MonitorPerformance("移动更新")]
    private void UpdateMovement()
    {
        // 移动逻辑
        var targetPosition = CalculateTargetPosition();
        transform.position = Vector3.Lerp(transform.position, targetPosition, Time.deltaTime * 2f);
    }
    
    [MonitorPerformance("动画更新")]
    private void UpdateAnimation()
    {
        // 动画逻辑
        var animator = GetComponent<Animator>();
        animator.SetFloat("Speed", GetComponent<Rigidbody>().velocity.magnitude);
    }
    
    private Vector3 CalculateTargetPosition()
    {
        // 复杂的位置计算
        return transform.position + Vector3.forward * Time.deltaTime;
    }
}
```

### 3. 手动监控代码块

```csharp
public class AIController : BaseModule
{
    void Update()
    {
        // 使用监控作用域
        using (PerformanceInterceptor.CreateScope("AI决策", "AIModule"))
        {
            MakeDecision();
        }
        
        // 使用扩展方法
        var pathfindingAction = CalculatePath.WithPerformanceMonitoring("路径计算", "AIModule");
        pathfindingAction();
    }
    
    private void MakeDecision()
    {
        // AI决策逻辑
        System.Threading.Thread.Sleep(1); // 模拟复杂计算
    }
    
    private void CalculatePath()
    {
        // 路径计算逻辑
        for (int i = 0; i < 1000; i++)
        {
            var distance = Vector3.Distance(Vector3.zero, Vector3.one * i);
        }
    }
}
```

### 4. 查看性能数据

```csharp
public class PerformanceReporter : MonoBehaviour
{
    void Start()
    {
        // 每5秒输出一次性能报告
        InvokeRepeating(nameof(PrintPerformanceReport), 5f, 5f);
    }
    
    private void PrintPerformanceReport()
    {
        var monitor = PerformanceMonitor.Instance;
        var allStats = monitor.GetAllStats();
        
        Debug.Log("=== 性能报告 ===");
        foreach (var kvp in allStats)
        {
            var stats = kvp.Value;
            Debug.Log($"{stats.OperationName}: 平均{stats.AverageTimeMs:F2}ms, 调用{stats.CallCount}次");
        }
        
        // 获取特定操作的详细统计
        var playerUpdateStats = monitor.GetStats("玩家更新");
        if (playerUpdateStats != null)
        {
            Debug.Log($"玩家更新详细统计: {playerUpdateStats}");
        }
    }
}
```

### 5. 在Unity编辑器中查看监控界面

1. 在Unity编辑器菜单中选择：`Cnoom Framework -> Performance Monitor`
2. 监控界面将显示：
   - 实时性能图表
   - 方法执行时间排行
   - 历史性能数据
   - 配置选项

### 6. 配置监控参数

```csharp
public class PerformanceConfig : MonoBehaviour
{
    void Start()
    {
        var monitor = PerformanceMonitor.Instance;
        
        // 启用/禁用监控
        monitor.SetEnabled(true);
        
        // 清空历史数据
        monitor.ClearStats();
        
        // 记录自定义性能数据
        monitor.RecordSample("自定义操作", TimeSpan.FromMilliseconds(15.5));
    }
}
```

## 高级用法

### 条件监控

```csharp
public class ConditionalMonitoring : BaseModule
{
    [MonitorPerformance("重型计算")]
    public void HeavyComputation()
    {
        // 只在开发版本中监控
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        using (PerformanceInterceptor.CreateScope("详细计算步骤"))
        {
            DetailedCalculation();
        }
        #else
        DetailedCalculation();
        #endif
    }
    
    private void DetailedCalculation()
    {
        // 复杂计算逻辑
    }
}
```

### 性能事件处理

```csharp
public class PerformanceEventHandler : BaseModule
{
    void Start()
    {
        // 监听性能相关事件
        EventBus.Subscribe<PerformanceWarningEvent>(OnPerformanceWarning);
    }
    
    private void OnPerformanceWarning(PerformanceWarningEvent evt)
    {
        if (evt.ExecutionTimeMs > 16.67f) // 超过一帧时间
        {
            Debug.LogWarning($"性能警告: {evt.OperationName} 执行时间过长 ({evt.ExecutionTimeMs:F2}ms)");
            
            // 可以在这里实现自动优化逻辑
            OptimizePerformance(evt.OperationName);
        }
    }
    
    private void OptimizePerformance(string operationName)
    {
        // 实现性能优化逻辑
        Debug.Log($"正在优化操作: {operationName}");
    }
}
```

## 最佳实践

### 1. 选择性监控
- 只监控关键路径和性能敏感的方法
- 避免监控过于频繁调用的简单方法
- 使用条件编译在发布版本中禁用详细监控

### 2. 合理命名
- 使用有意义的操作名称
- 保持命名一致性
- 包含模块信息便于分类

### 3. 性能优化
- 定期查看性能报告
- 关注平均执行时间和最大执行时间
- 优化执行时间超过16.67ms的操作（60FPS）

### 4. 数据管理
- 定期清理历史数据避免内存占用过多
- 在适当的时候禁用监控减少开销
- 使用采样策略处理高频操作

这个性能监控系统为您的Unity项目提供了强大而灵活的性能分析能力，帮助您快速识别和解决性能瓶颈！